#!/usr/bin/env node
// @generated by google-workspace-mcp-cli@0.1.0 on 2026-02-20T02:32:04.876Z. DO NOT EDIT.
import { Command } from 'commander';
import { createRuntime, createServerProxy } from 'mcporter';
import { createCallResult } from 'mcporter';

const embeddedServer = {
  "name": "alan-google",
  "description": "google-workspace-mcp",
  "command": {
    "kind": "stdio",
    "command": "npx",
    "args": [
      "-y",
      "@alanxchen/google-workspace-mcp@2.0.1"
    ]
  },
  "source": {
    "kind": "local",
    "path": "<adhoc>"
  }
} as const;
const embeddedSchemas = {
  "search_emails": {
    "type": "object",
    "properties": {
      "query": {
        "type": "string",
        "description": "Gmail search query"
      },
      "maxResults": {
        "type": "number",
        "description": "Maximum number of results (default: 10)"
      }
    },
    "required": [
      "query"
    ]
  },
  "read_email": {
    "type": "object",
    "properties": {
      "messageId": {
        "type": "string",
        "description": "Gmail message ID"
      }
    },
    "required": [
      "messageId"
    ]
  },
  "send_email": {
    "type": "object",
    "properties": {
      "to": {
        "type": "string",
        "description": "Recipient email address"
      },
      "subject": {
        "type": "string",
        "description": "Email subject"
      },
      "body": {
        "type": "string",
        "description": "Email body text"
      },
      "cc": {
        "type": "string",
        "description": "CC recipients (optional)"
      },
      "bcc": {
        "type": "string",
        "description": "BCC recipients (optional)"
      },
      "attachmentPaths": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Attachment file paths (optional)"
      },
      "attachments": {
        "type": "array",
        "description": "Detailed attachments with optional filename/mimeType overrides",
        "items": {
          "type": "object",
          "properties": {
            "filePath": {
              "type": "string",
              "description": "Attachment file path"
            },
            "filename": {
              "type": "string",
              "description": "Override attachment filename"
            },
            "mimeType": {
              "type": "string",
              "description": "Override attachment MIME type"
            }
          },
          "required": [
            "filePath"
          ]
        }
      }
    },
    "required": [
      "to",
      "subject",
      "body"
    ]
  },
  "reply_to_email": {
    "type": "object",
    "properties": {
      "messageId": {
        "type": "string",
        "description": "ID of message to reply to"
      },
      "body": {
        "type": "string",
        "description": "Reply body text"
      }
    },
    "required": [
      "messageId",
      "body"
    ]
  },
  "create_draft": {
    "type": "object",
    "properties": {
      "to": {
        "type": "string",
        "description": "Recipient email address"
      },
      "subject": {
        "type": "string",
        "description": "Email subject"
      },
      "body": {
        "type": "string",
        "description": "Email body text"
      },
      "cc": {
        "type": "string",
        "description": "CC recipients (optional)"
      },
      "bcc": {
        "type": "string",
        "description": "BCC recipients (optional)"
      }
    },
    "required": [
      "to",
      "subject",
      "body"
    ]
  },
  "trash_email": {
    "type": "object",
    "properties": {
      "messageId": {
        "type": "string",
        "description": "Gmail message ID"
      }
    },
    "required": [
      "messageId"
    ]
  },
  "mark_as_read": {
    "type": "object",
    "properties": {
      "messageId": {
        "type": "string",
        "description": "Gmail message ID"
      }
    },
    "required": [
      "messageId"
    ]
  },
  "mark_as_unread": {
    "type": "object",
    "properties": {
      "messageId": {
        "type": "string",
        "description": "Gmail message ID"
      }
    },
    "required": [
      "messageId"
    ]
  },
  "list_labels": {
    "type": "object",
    "properties": {}
  },
  "add_label": {
    "type": "object",
    "properties": {
      "messageId": {
        "type": "string",
        "description": "Gmail message ID"
      },
      "labelId": {
        "type": "string",
        "description": "Label ID to add"
      }
    },
    "required": [
      "messageId",
      "labelId"
    ]
  },
  "get_unsubscribe_options": {
    "type": "object",
    "properties": {
      "messageId": {
        "type": "string",
        "description": "Gmail message ID"
      }
    },
    "required": [
      "messageId"
    ]
  },
  "unsubscribe_email": {
    "type": "object",
    "properties": {
      "messageId": {
        "type": "string",
        "description": "Gmail message ID"
      },
      "method": {
        "type": "string",
        "enum": [
          "auto",
          "url_one_click",
          "url_get",
          "mailto"
        ],
        "description": "Unsubscribe strategy (default: auto)"
      },
      "dryRun": {
        "type": "boolean",
        "description": "Preview action without executing it"
      },
      "allowHttp": {
        "type": "boolean",
        "description": "Allow insecure http:// unsubscribe URLs (default: false)"
      }
    },
    "required": [
      "messageId"
    ]
  },
  "get_profile": {
    "type": "object",
    "properties": {}
  },
  "list_calendars": {
    "type": "object",
    "properties": {}
  },
  "list_events": {
    "type": "object",
    "properties": {
      "calendarId": {
        "type": "string",
        "description": "Calendar ID (default: \"primary\")"
      },
      "maxResults": {
        "type": "number",
        "description": "Maximum number of results (default: 10)"
      },
      "timeMin": {
        "type": "string",
        "description": "Start time (ISO 8601 format)"
      },
      "timeMax": {
        "type": "string",
        "description": "End time (ISO 8601 format)"
      }
    }
  },
  "get_event": {
    "type": "object",
    "properties": {
      "calendarId": {
        "type": "string",
        "description": "Calendar ID (default: \"primary\")"
      },
      "eventId": {
        "type": "string",
        "description": "Event ID"
      }
    },
    "required": [
      "eventId"
    ]
  },
  "create_event": {
    "type": "object",
    "properties": {
      "calendarId": {
        "type": "string",
        "description": "Calendar ID (default: \"primary\")"
      },
      "summary": {
        "type": "string",
        "description": "Event title"
      },
      "description": {
        "type": "string",
        "description": "Event description"
      },
      "location": {
        "type": "string",
        "description": "Event location"
      },
      "start": {
        "type": "string",
        "description": "Start time (ISO 8601 format)"
      },
      "end": {
        "type": "string",
        "description": "End time (ISO 8601 format)"
      },
      "attendees": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Attendee email addresses"
      },
      "timeZone": {
        "type": "string",
        "description": "Time zone"
      }
    },
    "required": [
      "summary",
      "start",
      "end"
    ]
  },
  "update_event": {
    "type": "object",
    "properties": {
      "calendarId": {
        "type": "string",
        "description": "Calendar ID (default: \"primary\")"
      },
      "eventId": {
        "type": "string",
        "description": "Event ID"
      },
      "summary": {
        "type": "string",
        "description": "Event title"
      },
      "description": {
        "type": "string",
        "description": "Event description"
      },
      "location": {
        "type": "string",
        "description": "Event location"
      },
      "start": {
        "type": "string",
        "description": "Start time (ISO 8601 format)"
      },
      "end": {
        "type": "string",
        "description": "End time (ISO 8601 format)"
      },
      "attendees": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Attendee email addresses"
      }
    },
    "required": [
      "eventId"
    ]
  },
  "delete_event": {
    "type": "object",
    "properties": {
      "calendarId": {
        "type": "string",
        "description": "Calendar ID (default: \"primary\")"
      },
      "eventId": {
        "type": "string",
        "description": "Event ID"
      }
    },
    "required": [
      "eventId"
    ]
  },
  "find_free_time": {
    "type": "object",
    "properties": {
      "timeMin": {
        "type": "string",
        "description": "Start time (ISO 8601 format)"
      },
      "timeMax": {
        "type": "string",
        "description": "End time (ISO 8601 format)"
      },
      "calendars": {
        "type": "array",
        "items": {
          "type": "string"
        },
        "description": "Calendar IDs to check"
      }
    },
    "required": [
      "timeMin",
      "timeMax"
    ]
  },
  "quick_add_event": {
    "type": "object",
    "properties": {
      "calendarId": {
        "type": "string",
        "description": "Calendar ID (default: \"primary\")"
      },
      "text": {
        "type": "string",
        "description": "Natural language event description"
      }
    },
    "required": [
      "text"
    ]
  },
  "list_files": {
    "type": "object",
    "properties": {
      "query": {
        "type": "string",
        "description": "Drive query string"
      },
      "maxResults": {
        "type": "number",
        "description": "Maximum number of results (default: 10)"
      },
      "orderBy": {
        "type": "string",
        "description": "Order by (e.g., \"modifiedTime desc\")"
      }
    }
  },
  "get_file": {
    "type": "object",
    "properties": {
      "fileId": {
        "type": "string",
        "description": "File ID"
      }
    },
    "required": [
      "fileId"
    ]
  },
  "search_files": {
    "type": "object",
    "properties": {
      "query": {
        "type": "string",
        "description": "Search query"
      },
      "maxResults": {
        "type": "number",
        "description": "Maximum number of results (default: 20)"
      }
    },
    "required": [
      "query"
    ]
  },
  "create_folder": {
    "type": "object",
    "properties": {
      "name": {
        "type": "string",
        "description": "Folder name"
      },
      "parentId": {
        "type": "string",
        "description": "Parent folder ID (optional)"
      }
    },
    "required": [
      "name"
    ]
  },
  "delete_file": {
    "type": "object",
    "properties": {
      "fileId": {
        "type": "string",
        "description": "File ID"
      }
    },
    "required": [
      "fileId"
    ]
  },
  "copy_file": {
    "type": "object",
    "properties": {
      "fileId": {
        "type": "string",
        "description": "File ID to copy"
      },
      "name": {
        "type": "string",
        "description": "New file name (optional)"
      },
      "parentId": {
        "type": "string",
        "description": "Parent folder ID (optional)"
      }
    },
    "required": [
      "fileId"
    ]
  },
  "move_file": {
    "type": "object",
    "properties": {
      "fileId": {
        "type": "string",
        "description": "File ID"
      },
      "newParentId": {
        "type": "string",
        "description": "New parent folder ID"
      }
    },
    "required": [
      "fileId",
      "newParentId"
    ]
  },
  "share_file": {
    "type": "object",
    "properties": {
      "fileId": {
        "type": "string",
        "description": "File ID"
      },
      "email": {
        "type": "string",
        "description": "Email address to share with"
      },
      "role": {
        "type": "string",
        "enum": [
          "reader",
          "writer",
          "commenter"
        ],
        "description": "Permission role"
      },
      "sendNotification": {
        "type": "boolean",
        "description": "Send email notification"
      }
    },
    "required": [
      "fileId",
      "email"
    ]
  },
  "get_file_content": {
    "type": "object",
    "properties": {
      "fileId": {
        "type": "string",
        "description": "File ID"
      },
      "mimeType": {
        "type": "string",
        "description": "MIME type (optional)"
      }
    },
    "required": [
      "fileId"
    ]
  },
  "export_file": {
    "type": "object",
    "properties": {
      "fileId": {
        "type": "string",
        "description": "File ID"
      },
      "mimeType": {
        "type": "string",
        "description": "Export MIME type (e.g., \"text/plain\", \"application/pdf\")"
      }
    },
    "required": [
      "fileId",
      "mimeType"
    ]
  },
  "get_storage_quota": {
    "type": "object",
    "properties": {}
  },
  "list_doc_structure": {
    "type": "object",
    "properties": {
      "documentId": {
        "type": "string",
        "description": "Google Doc document ID"
      }
    },
    "required": [
      "documentId"
    ]
  },
  "read_doc_text": {
    "type": "object",
    "properties": {
      "documentId": {
        "type": "string",
        "description": "Google Doc document ID"
      }
    },
    "required": [
      "documentId"
    ]
  },
  "create_doc": {
    "type": "object",
    "properties": {
      "title": {
        "type": "string",
        "description": "Document title"
      },
      "content": {
        "type": "string",
        "description": "Initial document text (optional)"
      }
    },
    "required": [
      "title"
    ]
  },
  "append_doc_text": {
    "type": "object",
    "properties": {
      "documentId": {
        "type": "string",
        "description": "Google Doc document ID"
      },
      "text": {
        "type": "string",
        "description": "Text to append"
      }
    },
    "required": [
      "documentId",
      "text"
    ]
  },
  "get_sheet_values": {
    "type": "object",
    "properties": {
      "spreadsheetId": {
        "type": "string",
        "description": "Spreadsheet ID"
      },
      "range": {
        "type": "string",
        "description": "A1 range (e.g., Sheet1!A1:C10)"
      }
    },
    "required": [
      "spreadsheetId",
      "range"
    ]
  },
  "update_sheet_values": {
    "type": "object",
    "properties": {
      "spreadsheetId": {
        "type": "string",
        "description": "Spreadsheet ID"
      },
      "range": {
        "type": "string",
        "description": "A1 range (e.g., Sheet1!A1:C10)"
      },
      "values": {
        "type": "array",
        "items": {
          "type": "array",
          "items": {}
        },
        "description": "2D values array"
      },
      "valueInputOption": {
        "type": "string",
        "enum": [
          "RAW",
          "USER_ENTERED"
        ]
      }
    },
    "required": [
      "spreadsheetId",
      "range",
      "values"
    ]
  },
  "append_sheet_values": {
    "type": "object",
    "properties": {
      "spreadsheetId": {
        "type": "string",
        "description": "Spreadsheet ID"
      },
      "range": {
        "type": "string",
        "description": "A1 range (e.g., Sheet1!A:C)"
      },
      "values": {
        "type": "array",
        "items": {
          "type": "array",
          "items": {}
        },
        "description": "2D values array"
      },
      "valueInputOption": {
        "type": "string",
        "enum": [
          "RAW",
          "USER_ENTERED"
        ]
      }
    },
    "required": [
      "spreadsheetId",
      "range",
      "values"
    ]
  },
  "create_spreadsheet": {
    "type": "object",
    "properties": {
      "title": {
        "type": "string",
        "description": "Spreadsheet title"
      },
      "sheetTitle": {
        "type": "string",
        "description": "Initial sheet tab name"
      }
    },
    "required": [
      "title"
    ]
  },
  "get_presentation": {
    "type": "object",
    "properties": {
      "presentationId": {
        "type": "string",
        "description": "Presentation ID"
      }
    },
    "required": [
      "presentationId"
    ]
  },
  "create_presentation": {
    "type": "object",
    "properties": {
      "title": {
        "type": "string",
        "description": "Presentation title"
      }
    },
    "required": [
      "title"
    ]
  },
  "create_slide": {
    "type": "object",
    "properties": {
      "presentationId": {
        "type": "string",
        "description": "Presentation ID"
      },
      "layout": {
        "type": "string",
        "description": "Layout enum, e.g. TITLE_AND_BODY"
      }
    },
    "required": [
      "presentationId"
    ]
  },
  "list_contacts": {
    "type": "object",
    "properties": {
      "pageSize": {
        "type": "number",
        "description": "Page size (default 50)"
      },
      "pageToken": {
        "type": "string",
        "description": "Pagination token"
      }
    }
  },
  "search_contacts": {
    "type": "object",
    "properties": {
      "query": {
        "type": "string",
        "description": "Search query"
      },
      "pageSize": {
        "type": "number",
        "description": "Page size (default 20)"
      }
    },
    "required": [
      "query"
    ]
  },
  "create_contact": {
    "type": "object",
    "properties": {
      "givenName": {
        "type": "string",
        "description": "First name"
      },
      "familyName": {
        "type": "string",
        "description": "Last name"
      },
      "email": {
        "type": "string",
        "description": "Email address"
      },
      "phone": {
        "type": "string",
        "description": "Phone number"
      },
      "company": {
        "type": "string",
        "description": "Company name"
      }
    },
    "required": [
      "givenName"
    ]
  },
  "get_contact": {
    "type": "object",
    "properties": {
      "resourceName": {
        "type": "string",
        "description": "Resource name like people/c123456789"
      }
    },
    "required": [
      "resourceName"
    ]
  }
} as const;
const embeddedName = "alan-google";
const embeddedDescription = "google-workspace-mcp";
const generatorInfo = "Generated by google-workspace-mcp-cli@0.1.0 â€” https://github.com/steipete/mcporter";
const generatorTools = [
  {
    "name": "search-emails",
    "description": "Search emails using Gmail query syntax (e.g., \"is:unread\", \"from:example@gmail.com\")",
    "usage": "search-emails --query <query> [--max-results <max-results:number>] [--raw <json>]",
    "flags": "--query <query> [--max-results <max-results:number>] [--raw <json>]"
  },
  {
    "name": "read-email",
    "description": "Read a specific email by its message ID",
    "usage": "read-email --message-id <message-id> [--raw <json>]",
    "flags": "--message-id <message-id> [--raw <json>]"
  },
  {
    "name": "send-email",
    "description": "Send a new email (supports optional file attachments)",
    "usage": "send-email --to <to> --subject <subject> --body <body> [--cc <cc>] [--bcc <bcc>] [--raw <json>]",
    "flags": "--to <to> --subject <subject> --body <body> [--cc <cc>] [--bcc <bcc>] [--raw <json>]"
  },
  {
    "name": "reply-to-email",
    "description": "Reply to an existing email",
    "usage": "reply-to-email --message-id <message-id> --body <body> [--raw <json>]",
    "flags": "--message-id <message-id> --body <body> [--raw <json>]"
  },
  {
    "name": "create-draft",
    "description": "Create an email draft",
    "usage": "create-draft --to <to> --subject <subject> --body <body> [--cc <cc>] [--bcc <bcc>] [--raw <json>]",
    "flags": "--to <to> --subject <subject> --body <body> [--cc <cc>] [--bcc <bcc>] [--raw <json>]"
  },
  {
    "name": "trash-email",
    "description": "Move an email to trash",
    "usage": "trash-email --message-id <message-id> [--raw <json>]",
    "flags": "--message-id <message-id> [--raw <json>]"
  },
  {
    "name": "mark-as-read",
    "description": "Mark an email as read",
    "usage": "mark-as-read --message-id <message-id> [--raw <json>]",
    "flags": "--message-id <message-id> [--raw <json>]"
  },
  {
    "name": "mark-as-unread",
    "description": "Mark an email as unread",
    "usage": "mark-as-unread --message-id <message-id> [--raw <json>]",
    "flags": "--message-id <message-id> [--raw <json>]"
  },
  {
    "name": "list-labels",
    "description": "List all Gmail labels",
    "usage": "list-labels [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "add-label",
    "description": "Add a label to a message",
    "usage": "add-label --message-id <message-id> --label-id <label-id> [--raw <json>]",
    "flags": "--message-id <message-id> --label-id <label-id> [--raw <json>]"
  },
  {
    "name": "get-unsubscribe-options",
    "description": "Inspect List-Unsubscribe headers and available unsubscribe methods for an email",
    "usage": "get-unsubscribe-options --message-id <message-id> [--raw <json>]",
    "flags": "--message-id <message-id> [--raw <json>]"
  },
  {
    "name": "unsubscribe-email",
    "description": "Attempt unsubscribe via List-Unsubscribe (one-click POST, URL GET, or mailto draft fallback)",
    "usage": "unsubscribe-email --message-id <message-id> [--method <method:auto|url_one_click|url_get|mailto>] [--dry-run <dry-run:true|false>] [--allow-http <allow-http:true|false>] [--raw <json>]",
    "flags": "--message-id <message-id> [--method <method:auto|url_one_click|url_get|mailto>] [--dry-run <dry-run:true|false>] [--allow-http <allow-http:true|false>] [--raw <json>]"
  },
  {
    "name": "get-profile",
    "description": "Get Gmail profile information",
    "usage": "get-profile [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "list-calendars",
    "description": "List all available calendars",
    "usage": "list-calendars [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "list-events",
    "description": "List upcoming calendar events",
    "usage": "list-events [--calendar-id <calendar-id>] [--max-results <max-results:number>] [--time-min <time-min:iso-8601>] [--time-max <time-max:iso-8601>] [--raw <json>]",
    "flags": "[--calendar-id <calendar-id>] [--max-results <max-results:number>] [--time-min <time-min:iso-8601>] [--time-max <time-max:iso-8601>] [--raw <json>]"
  },
  {
    "name": "get-event",
    "description": "Get details of a specific calendar event",
    "usage": "get-event [--calendar-id <calendar-id>] --event-id <event-id> [--raw <json>]",
    "flags": "[--calendar-id <calendar-id>] --event-id <event-id> [--raw <json>]"
  },
  {
    "name": "create-event",
    "description": "Create a new calendar event",
    "usage": "create-event [--calendar-id <calendar-id>] --summary <summary> [--description <description>] --start <start:iso-8601> --end <end:iso-8601> [--raw <json>]",
    "flags": "[--calendar-id <calendar-id>] --summary <summary> [--description <description>] --start <start:iso-8601> --end <end:iso-8601> [--raw <json>]"
  },
  {
    "name": "update-event",
    "description": "Update an existing calendar event",
    "usage": "update-event [--calendar-id <calendar-id>] --event-id <event-id> [--summary <summary>] [--description <description>] [--location <location>] [--raw <json>]",
    "flags": "[--calendar-id <calendar-id>] --event-id <event-id> [--summary <summary>] [--description <description>] [--location <location>] [--raw <json>]"
  },
  {
    "name": "delete-event",
    "description": "Delete a calendar event",
    "usage": "delete-event [--calendar-id <calendar-id>] --event-id <event-id> [--raw <json>]",
    "flags": "[--calendar-id <calendar-id>] --event-id <event-id> [--raw <json>]"
  },
  {
    "name": "find-free-time",
    "description": "Find free time slots across calendars",
    "usage": "find-free-time --time-min <time-min:iso-8601> --time-max <time-max:iso-8601> [--calendars <calendars:value1,value2>] [--raw <json>]",
    "flags": "--time-min <time-min:iso-8601> --time-max <time-max:iso-8601> [--calendars <calendars:value1,value2>] [--raw <json>]"
  },
  {
    "name": "quick-add-event",
    "description": "Create event using natural language (e.g., \"Lunch tomorrow at noon\")",
    "usage": "quick-add-event [--calendar-id <calendar-id>] --text <text> [--raw <json>]",
    "flags": "[--calendar-id <calendar-id>] --text <text> [--raw <json>]"
  },
  {
    "name": "list-files",
    "description": "List files in Google Drive",
    "usage": "list-files [--query <query>] [--max-results <max-results:number>] [--order-by <order-by>] [--raw <json>]",
    "flags": "[--query <query>] [--max-results <max-results:number>] [--order-by <order-by>] [--raw <json>]"
  },
  {
    "name": "get-file",
    "description": "Get metadata for a specific file",
    "usage": "get-file --file-id <file-id> [--raw <json>]",
    "flags": "--file-id <file-id> [--raw <json>]"
  },
  {
    "name": "search-files",
    "description": "Search files by name or content",
    "usage": "search-files --query <query> [--max-results <max-results:number>] [--raw <json>]",
    "flags": "--query <query> [--max-results <max-results:number>] [--raw <json>]"
  },
  {
    "name": "create-folder",
    "description": "Create a new folder in Drive",
    "usage": "create-folder --name <name> [--parent-id <parent-id>] [--raw <json>]",
    "flags": "--name <name> [--parent-id <parent-id>] [--raw <json>]"
  },
  {
    "name": "delete-file",
    "description": "Delete a file from Drive",
    "usage": "delete-file --file-id <file-id> [--raw <json>]",
    "flags": "--file-id <file-id> [--raw <json>]"
  },
  {
    "name": "copy-file",
    "description": "Create a copy of a file",
    "usage": "copy-file --file-id <file-id> [--name <name>] [--parent-id <parent-id>] [--raw <json>]",
    "flags": "--file-id <file-id> [--name <name>] [--parent-id <parent-id>] [--raw <json>]"
  },
  {
    "name": "move-file",
    "description": "Move a file to a different folder",
    "usage": "move-file --file-id <file-id> --new-parent-id <new-parent-id> [--raw <json>]",
    "flags": "--file-id <file-id> --new-parent-id <new-parent-id> [--raw <json>]"
  },
  {
    "name": "share-file",
    "description": "Share a file with someone",
    "usage": "share-file --file-id <file-id> --email <email> [--role <role:reader|writer|commenter>] [--send-notification <send-notification:true|false>] [--raw <json>]",
    "flags": "--file-id <file-id> --email <email> [--role <role:reader|writer|commenter>] [--send-notification <send-notification:true|false>] [--raw <json>]"
  },
  {
    "name": "get-file-content",
    "description": "Get content of a text file",
    "usage": "get-file-content --file-id <file-id> [--mime-type <mime-type>] [--raw <json>]",
    "flags": "--file-id <file-id> [--mime-type <mime-type>] [--raw <json>]"
  },
  {
    "name": "export-file",
    "description": "Export a Google Doc/Sheet/Slides to another format",
    "usage": "export-file --file-id <file-id> --mime-type <mime-type> [--raw <json>]",
    "flags": "--file-id <file-id> --mime-type <mime-type> [--raw <json>]"
  },
  {
    "name": "get-storage-quota",
    "description": "Get Drive storage quota information",
    "usage": "get-storage-quota [--raw <json>]",
    "flags": "[--raw <json>]"
  },
  {
    "name": "list-doc-structure",
    "description": "List high-level structure of a Google Doc",
    "usage": "list-doc-structure --document-id <document-id> [--raw <json>]",
    "flags": "--document-id <document-id> [--raw <json>]"
  },
  {
    "name": "read-doc-text",
    "description": "Read plain text content from a Google Doc",
    "usage": "read-doc-text --document-id <document-id> [--raw <json>]",
    "flags": "--document-id <document-id> [--raw <json>]"
  },
  {
    "name": "create-doc",
    "description": "Create a new Google Doc with optional initial content",
    "usage": "create-doc --title <title> [--content <content>] [--raw <json>]",
    "flags": "--title <title> [--content <content>] [--raw <json>]"
  },
  {
    "name": "append-doc-text",
    "description": "Append text to the end of a Google Doc",
    "usage": "append-doc-text --document-id <document-id> --text <text> [--raw <json>]",
    "flags": "--document-id <document-id> --text <text> [--raw <json>]"
  },
  {
    "name": "get-sheet-values",
    "description": "Read values from a spreadsheet range",
    "usage": "get-sheet-values --spreadsheet-id <spreadsheet-id> --range <range> [--raw <json>]",
    "flags": "--spreadsheet-id <spreadsheet-id> --range <range> [--raw <json>]"
  },
  {
    "name": "update-sheet-values",
    "description": "Update values in a spreadsheet range",
    "usage": "update-sheet-values --spreadsheet-id <spreadsheet-id> --range <range> --values <values:value1,value2> [--value-input-option <value-input-option:RAW|USER_ENTERED>] [--raw <json>]",
    "flags": "--spreadsheet-id <spreadsheet-id> --range <range> --values <values:value1,value2> [--value-input-option <value-input-option:RAW|USER_ENTERED>] [--raw <json>]"
  },
  {
    "name": "append-sheet-values",
    "description": "Append rows to a spreadsheet range",
    "usage": "append-sheet-values --spreadsheet-id <spreadsheet-id> --range <range> --values <values:value1,value2> [--value-input-option <value-input-option:RAW|USER_ENTERED>] [--raw <json>]",
    "flags": "--spreadsheet-id <spreadsheet-id> --range <range> --values <values:value1,value2> [--value-input-option <value-input-option:RAW|USER_ENTERED>] [--raw <json>]"
  },
  {
    "name": "create-spreadsheet",
    "description": "Create a new Google Spreadsheet",
    "usage": "create-spreadsheet --title <title> [--sheet-title <sheet-title>] [--raw <json>]",
    "flags": "--title <title> [--sheet-title <sheet-title>] [--raw <json>]"
  },
  {
    "name": "get-presentation",
    "description": "Get metadata and slides for a Google Slides presentation",
    "usage": "get-presentation --presentation-id <presentation-id> [--raw <json>]",
    "flags": "--presentation-id <presentation-id> [--raw <json>]"
  },
  {
    "name": "create-presentation",
    "description": "Create a new Google Slides presentation",
    "usage": "create-presentation --title <title> [--raw <json>]",
    "flags": "--title <title> [--raw <json>]"
  },
  {
    "name": "create-slide",
    "description": "Create a slide in an existing presentation",
    "usage": "create-slide --presentation-id <presentation-id> [--layout <layout>] [--raw <json>]",
    "flags": "--presentation-id <presentation-id> [--layout <layout>] [--raw <json>]"
  },
  {
    "name": "list-contacts",
    "description": "List contacts from Google People",
    "usage": "list-contacts [--page-size <page-size:number>] [--page-token <page-token>] [--raw <json>]",
    "flags": "[--page-size <page-size:number>] [--page-token <page-token>] [--raw <json>]"
  },
  {
    "name": "search-contacts",
    "description": "Search contacts by name/email/phone",
    "usage": "search-contacts --query <query> [--page-size <page-size:number>] [--raw <json>]",
    "flags": "--query <query> [--page-size <page-size:number>] [--raw <json>]"
  },
  {
    "name": "create-contact",
    "description": "Create a contact in Google People",
    "usage": "create-contact --given-name <given-name> [--family-name <family-name>] [--email <email>] [--phone <phone>] [--company <company>] [--raw <json>]",
    "flags": "--given-name <given-name> [--family-name <family-name>] [--email <email>] [--phone <phone>] [--company <company>] [--raw <json>]"
  },
  {
    "name": "get-contact",
    "description": "Get a contact by People resource name",
    "usage": "get-contact --resource-name <resource-name> [--raw <json>]",
    "flags": "--resource-name <resource-name> [--raw <json>]"
  }
] as const;
const embeddedMetadata = {
  "schemaVersion": 1,
  "generatedAt": "2026-02-20T02:32:04.876Z",
  "generator": {
    "name": "google-workspace-mcp-cli",
    "version": "0.1.0"
  },
  "server": {
    "name": "alan-google",
    "source": {
      "kind": "local",
      "path": "<adhoc>"
    },
    "definition": {
      "name": "alan-google",
      "description": "google-workspace-mcp",
      "command": {
        "kind": "stdio",
        "command": "npx",
        "args": [
          "-y",
          "@alanxchen/google-workspace-mcp@2.0.1"
        ]
      }
    }
  },
  "artifact": {
    "path": "",
    "kind": "template"
  },
  "invocation": {
    "serverRef": "{\"name\":\"alan-google\",\"description\":\"google-workspace-mcp\",\"command\":{\"kind\":\"stdio\",\"command\":\"npx\",\"args\":[\"-y\",\"@alanxchen/google-workspace-mcp@2.0.1\"]},\"source\":{\"kind\":\"local\",\"path\":\"<adhoc>\"}}",
    "configPath": "<adhoc>",
    "runtime": "node",
    "bundler": "rolldown",
    "outputPath": "/data/dev/google-workspace-mcp-cli/alan-google.ts",
    "timeoutMs": 30000,
    "minify": false
  }
} as const;
const artifactKind = determineArtifactKind();
const program = new Command();
program.name(embeddedName);
program.description(embeddedDescription);
program.option('-t, --timeout <ms>', 'Call timeout in milliseconds', (value) => parseInt(value, 10), 30000);
program.option('-o, --output <format>', 'Output format: text|markdown|json|raw', 'text');
const commandSignatures: Record<string, string> = {
  "search-emails": "function search_emails(query: string, maxResults?: number);",
  "read-email": "function read_email(messageId: string);",
  "send-email": "function send_email(to: string, subject: string, body: string, cc?: string, bcc?: string);",
  "reply-to-email": "function reply_to_email(messageId: string, body: string);",
  "create-draft": "function create_draft(to: string, subject: string, body: string, cc?: string, bcc?: string);",
  "trash-email": "function trash_email(messageId: string);",
  "mark-as-read": "function mark_as_read(messageId: string);",
  "mark-as-unread": "function mark_as_unread(messageId: string);",
  "list-labels": "function list_labels();",
  "add-label": "function add_label(messageId: string, labelId: string);",
  "get-unsubscribe-options": "function get_unsubscribe_options(messageId: string);",
  "unsubscribe-email": "function unsubscribe_email(messageId: string, method?: \"auto\" | \"url_one_click\" | \"url_get\" | \"mailto\", dryRun?: boolean, allowHttp?: boolean);",
  "get-profile": "function get_profile();",
  "list-calendars": "function list_calendars();",
  "list-events": "function list_events(calendarId?: string, maxResults?: number, timeMin?: string, timeMax?: string);",
  "get-event": "function get_event(calendarId?: string, eventId: string);",
  "create-event": "function create_event(calendarId?: string, summary: string, description?: string, start: string, end: string);",
  "update-event": "function update_event(calendarId?: string, eventId: string, summary?: string, description?: string, location?: string);",
  "delete-event": "function delete_event(calendarId?: string, eventId: string);",
  "find-free-time": "function find_free_time(timeMin: string, timeMax: string, calendars?: string[]);",
  "quick-add-event": "function quick_add_event(calendarId?: string, text: string);",
  "list-files": "function list_files(query?: string, maxResults?: number, orderBy?: string);",
  "get-file": "function get_file(fileId: string);",
  "search-files": "function search_files(query: string, maxResults?: number);",
  "create-folder": "function create_folder(name: string, parentId?: string);",
  "delete-file": "function delete_file(fileId: string);",
  "copy-file": "function copy_file(fileId: string, name?: string, parentId?: string);",
  "move-file": "function move_file(fileId: string, newParentId: string);",
  "share-file": "function share_file(fileId: string, email: string, role?: \"reader\" | \"writer\" | \"commenter\", sendNotification?: boolean);",
  "get-file-content": "function get_file_content(fileId: string, mimeType?: string);",
  "export-file": "function export_file(fileId: string, mimeType: string);",
  "get-storage-quota": "function get_storage_quota();",
  "list-doc-structure": "function list_doc_structure(documentId: string);",
  "read-doc-text": "function read_doc_text(documentId: string);",
  "create-doc": "function create_doc(title: string, content?: string);",
  "append-doc-text": "function append_doc_text(documentId: string, text: string);",
  "get-sheet-values": "function get_sheet_values(spreadsheetId: string, range: string);",
  "update-sheet-values": "function update_sheet_values(spreadsheetId: string, range: string, values: string[], valueInputOption?: \"RAW\" | \"USER_ENTERED\");",
  "append-sheet-values": "function append_sheet_values(spreadsheetId: string, range: string, values: string[], valueInputOption?: \"RAW\" | \"USER_ENTERED\");",
  "create-spreadsheet": "function create_spreadsheet(title: string, sheetTitle?: string);",
  "get-presentation": "function get_presentation(presentationId: string);",
  "create-presentation": "function create_presentation(title: string);",
  "create-slide": "function create_slide(presentationId: string, layout?: string);",
  "list-contacts": "function list_contacts(pageSize?: number, pageToken?: string);",
  "search-contacts": "function search_contacts(query: string, pageSize?: number);",
  "create-contact": "function create_contact(givenName: string, familyName?: string, email?: string, phone?: string, company?: string);",
  "get-contact": "function get_contact(resourceName: string);"
};
program.configureHelp({
	commandTerm(cmd) {
		const term = cmd.name();
		return commandSignatures[term] ?? cmd.name();
	},
});
program.showSuggestionAfterError(true);

program
	.command("search-emails")
	.summary("search-emails --query <query> [--max-results <max-results:number>] [--raw <json>]")
	.description("Search emails using Gmail query syntax (e.g., \"is:unread\", \"from:example@gmail.com\")")
	.usage("--query <query> [--max-results <max-results:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--query <query>", "Gmail search query")
	.option("--max-results <max-results:number>", "Maximum number of results (default: 10) (example: 1)", (value) => parseFloat(value))
	
	.alias("search_emails")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
		if (cmdOpts.maxResults !== undefined) args.maxResults = cmdOpts.maxResults;
			const call = (proxy.searchEmails as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.search_emails(query: \"value\", maxResults: 1)");

program
	.command("read-email")
	.summary("read-email --message-id <message-id> [--raw <json>]")
	.description("Read a specific email by its message ID")
	.usage("--message-id <message-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--message-id <message-id>", "Gmail message ID (example: example-id)")
	
	.alias("read_email")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.messageId !== undefined) args.messageId = cmdOpts.messageId;
			const call = (proxy.readEmail as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.read_email(messageId: \"example-id\")");

program
	.command("send-email")
	.summary("send-email --to <to> --subject <subject> --body <body> [--cc <cc>] [--bcc <bcc>] [--raw <json>]")
	.description("Send a new email (supports optional file attachments)")
	.usage("--to <to> --subject <subject> --body <body> [--cc <cc>] [--bcc <bcc>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--to <to>", "Recipient email address")
	.requiredOption("--subject <subject>", "Email subject")
	.requiredOption("--body <body>", "Email body text")
	.option("--cc <cc>", "CC recipients (optional)")
	.option("--bcc <bcc>", "BCC recipients (optional)")
	.option("--attachment-paths <attachment-paths:value1,value2>", "Attachment file paths (optional) (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--attachments <attachments:value1,value2>", "Detailed attachments with optional filename/mimeType overrides (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	
	.alias("send_email")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.to !== undefined) args.to = cmdOpts.to;
		if (cmdOpts.subject !== undefined) args.subject = cmdOpts.subject;
		if (cmdOpts.body !== undefined) args.body = cmdOpts.body;
		if (cmdOpts.cc !== undefined) args.cc = cmdOpts.cc;
		if (cmdOpts.bcc !== undefined) args.bcc = cmdOpts.bcc;
		if (cmdOpts.attachmentPaths !== undefined) args.attachmentPaths = cmdOpts.attachmentPaths;
		if (cmdOpts.attachments !== undefined) args.attachments = cmdOpts.attachments;
			const call = (proxy.sendEmail as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.send_email(to: \"value\", subject: \"value\", body:, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (2): attachmentPaths, attachments" + '\n');

program
	.command("reply-to-email")
	.summary("reply-to-email --message-id <message-id> --body <body> [--raw <json>]")
	.description("Reply to an existing email")
	.usage("--message-id <message-id> --body <body> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--message-id <message-id>", "ID of message to reply to (example: example-id)")
	.requiredOption("--body <body>", "Reply body text")
	
	.alias("reply_to_email")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.messageId !== undefined) args.messageId = cmdOpts.messageId;
		if (cmdOpts.body !== undefined) args.body = cmdOpts.body;
			const call = (proxy.replyToEmail as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.reply_to_email(messageId: \"example-id\", body: \"value\")");

program
	.command("create-draft")
	.summary("create-draft --to <to> --subject <subject> --body <body> [--cc <cc>] [--bcc <bcc>] [--raw <json>]")
	.description("Create an email draft")
	.usage("--to <to> --subject <subject> --body <body> [--cc <cc>] [--bcc <bcc>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--to <to>", "Recipient email address")
	.requiredOption("--subject <subject>", "Email subject")
	.requiredOption("--body <body>", "Email body text")
	.option("--cc <cc>", "CC recipients (optional)")
	.option("--bcc <bcc>", "BCC recipients (optional)")
	
	.alias("create_draft")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.to !== undefined) args.to = cmdOpts.to;
		if (cmdOpts.subject !== undefined) args.subject = cmdOpts.subject;
		if (cmdOpts.body !== undefined) args.body = cmdOpts.body;
		if (cmdOpts.cc !== undefined) args.cc = cmdOpts.cc;
		if (cmdOpts.bcc !== undefined) args.bcc = cmdOpts.bcc;
			const call = (proxy.createDraft as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.create_draft(to: \"value\", subject: \"value\", body, ...)");

program
	.command("trash-email")
	.summary("trash-email --message-id <message-id> [--raw <json>]")
	.description("Move an email to trash")
	.usage("--message-id <message-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--message-id <message-id>", "Gmail message ID (example: example-id)")
	
	.alias("trash_email")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.messageId !== undefined) args.messageId = cmdOpts.messageId;
			const call = (proxy.trashEmail as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.trash_email(messageId: \"example-id\")");

program
	.command("mark-as-read")
	.summary("mark-as-read --message-id <message-id> [--raw <json>]")
	.description("Mark an email as read")
	.usage("--message-id <message-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--message-id <message-id>", "Gmail message ID (example: example-id)")
	
	.alias("mark_as_read")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.messageId !== undefined) args.messageId = cmdOpts.messageId;
			const call = (proxy.markAsRead as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.mark_as_read(messageId: \"example-id\")");

program
	.command("mark-as-unread")
	.summary("mark-as-unread --message-id <message-id> [--raw <json>]")
	.description("Mark an email as unread")
	.usage("--message-id <message-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--message-id <message-id>", "Gmail message ID (example: example-id)")
	
	.alias("mark_as_unread")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.messageId !== undefined) args.messageId = cmdOpts.messageId;
			const call = (proxy.markAsUnread as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.mark_as_unread(messageId: \"example-id\")");

program
	.command("list-labels")
	.summary("list-labels [--raw <json>]")
	.description("List all Gmail labels")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	
	.alias("list_labels")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.listLabels as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.list_labels()");

program
	.command("add-label")
	.summary("add-label --message-id <message-id> --label-id <label-id> [--raw <json>]")
	.description("Add a label to a message")
	.usage("--message-id <message-id> --label-id <label-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--message-id <message-id>", "Gmail message ID (example: example-id)")
	.requiredOption("--label-id <label-id>", "Label ID to add (example: example-id)")
	
	.alias("add_label")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.messageId !== undefined) args.messageId = cmdOpts.messageId;
		if (cmdOpts.labelId !== undefined) args.labelId = cmdOpts.labelId;
			const call = (proxy.addLabel as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.add_label(messageId: \"example-id\", labelId: \"exa, ...)");

program
	.command("get-unsubscribe-options")
	.summary("get-unsubscribe-options --message-id <message-id> [--raw <json>]")
	.description("Inspect List-Unsubscribe headers and available unsubscribe methods for an email")
	.usage("--message-id <message-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--message-id <message-id>", "Gmail message ID (example: example-id)")
	
	.alias("get_unsubscribe_options")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.messageId !== undefined) args.messageId = cmdOpts.messageId;
			const call = (proxy.getUnsubscribeOptions as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.get_unsubscribe_options(messageId: \"example-id\")");

program
	.command("unsubscribe-email")
	.summary("unsubscribe-email --message-id <message-id> [--method <method:auto|url_one_click|url_get|mailto>] [--dry-run <dry-run:true|false>] [--allow-http <allow-http:true|false>] [--raw <json>]")
	.description("Attempt unsubscribe via List-Unsubscribe (one-click POST, URL GET, or mailto draft fallback)")
	.usage("--message-id <message-id> [--method <method:auto|url_one_click|url_get|mailto>] [--dry-run <dry-run:true|false>] [--allow-http <allow-http:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--message-id <message-id>", "Gmail message ID (example: example-id)")
	.option("--method <method:auto|url_one_click|url_get|mailto>", "Unsubscribe strategy (default: auto) (choices: auto, url_one_click, url_get, mailto; example: auto)")
	.option("--dry-run <dry-run:true|false>", "Preview action without executing it (example: true)", (value) => value !== 'false')
	.option("--allow-http <allow-http:true|false>", "Allow insecure http:// unsubscribe URLs (default: false) (example: true)", (value) => value !== 'false')
	
	.alias("unsubscribe_email")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.messageId !== undefined) args.messageId = cmdOpts.messageId;
		if (cmdOpts.method !== undefined) args.method = cmdOpts.method;
		if (cmdOpts.dryRun !== undefined) args.dryRun = cmdOpts.dryRun;
		if (cmdOpts.allowHttp !== undefined) args.allowHttp = cmdOpts.allowHttp;
			const call = (proxy.unsubscribeEmail as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.unsubscribe_email(messageId: \"example-id\", metho, ...)");

program
	.command("get-profile")
	.summary("get-profile [--raw <json>]")
	.description("Get Gmail profile information")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	
	.alias("get_profile")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.getProfile as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.get_profile()");

program
	.command("list-calendars")
	.summary("list-calendars [--raw <json>]")
	.description("List all available calendars")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	
	.alias("list_calendars")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.listCalendars as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.list_calendars()");

program
	.command("list-events")
	.summary("list-events [--calendar-id <calendar-id>] [--max-results <max-results:number>] [--time-min <time-min:iso-8601>] [--time-max <time-max:iso-8601>] [--raw <json>]")
	.description("List upcoming calendar events")
	.usage("[--calendar-id <calendar-id>] [--max-results <max-results:number>] [--time-min <time-min:iso-8601>] [--time-max <time-max:iso-8601>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--calendar-id <calendar-id>", "Calendar ID (default: \"primary\") (example: example-id)")
	.option("--max-results <max-results:number>", "Maximum number of results (default: 10) (example: 1)", (value) => parseFloat(value))
	.option("--time-min <time-min:iso-8601>", "Start time (ISO 8601 format)")
	.option("--time-max <time-max:iso-8601>", "End time (ISO 8601 format)")
	
	.alias("list_events")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.calendarId !== undefined) args.calendarId = cmdOpts.calendarId;
		if (cmdOpts.maxResults !== undefined) args.maxResults = cmdOpts.maxResults;
		if (cmdOpts.timeMin !== undefined) args.timeMin = cmdOpts.timeMin;
		if (cmdOpts.timeMax !== undefined) args.timeMax = cmdOpts.timeMax;
			const call = (proxy.listEvents as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.list_events(calendarId: \"example-id\", maxResults: 1)");

program
	.command("get-event")
	.summary("get-event [--calendar-id <calendar-id>] --event-id <event-id> [--raw <json>]")
	.description("Get details of a specific calendar event")
	.usage("[--calendar-id <calendar-id>] --event-id <event-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--calendar-id <calendar-id>", "Calendar ID (default: \"primary\") (example: example-id)")
	.requiredOption("--event-id <event-id>", "Event ID (example: example-id)")
	
	.alias("get_event")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.calendarId !== undefined) args.calendarId = cmdOpts.calendarId;
		if (cmdOpts.eventId !== undefined) args.eventId = cmdOpts.eventId;
			const call = (proxy.getEvent as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.get_event(calendarId: \"example-id\", eventId: \"ex, ...)");

program
	.command("create-event")
	.summary("create-event [--calendar-id <calendar-id>] --summary <summary> [--description <description>] --start <start:iso-8601> --end <end:iso-8601> [--raw <json>]")
	.description("Create a new calendar event")
	.usage("[--calendar-id <calendar-id>] --summary <summary> [--description <description>] --start <start:iso-8601> --end <end:iso-8601> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--calendar-id <calendar-id>", "Calendar ID (default: \"primary\") (example: example-id)")
	.requiredOption("--summary <summary>", "Event title")
	.option("--description <description>", "Event description")
	.option("--location <location>", "Event location")
	.requiredOption("--start <start:iso-8601>", "Start time (ISO 8601 format)")
	.requiredOption("--end <end:iso-8601>", "End time (ISO 8601 format)")
	.option("--attendees <attendees:value1,value2>", "Attendee email addresses (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--time-zone <time-zone>", "Time zone")
	
	.alias("create_event")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.calendarId !== undefined) args.calendarId = cmdOpts.calendarId;
		if (cmdOpts.summary !== undefined) args.summary = cmdOpts.summary;
		if (cmdOpts.description !== undefined) args.description = cmdOpts.description;
		if (cmdOpts.location !== undefined) args.location = cmdOpts.location;
		if (cmdOpts.start !== undefined) args.start = cmdOpts.start;
		if (cmdOpts.end !== undefined) args.end = cmdOpts.end;
		if (cmdOpts.attendees !== undefined) args.attendees = cmdOpts.attendees;
		if (cmdOpts.timeZone !== undefined) args.timeZone = cmdOpts.timeZone;
			const call = (proxy.createEvent as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.create_event(calendarId: \"example-id\", summary:, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (3): location, attendees, timeZone" + '\n');

program
	.command("update-event")
	.summary("update-event [--calendar-id <calendar-id>] --event-id <event-id> [--summary <summary>] [--description <description>] [--location <location>] [--raw <json>]")
	.description("Update an existing calendar event")
	.usage("[--calendar-id <calendar-id>] --event-id <event-id> [--summary <summary>] [--description <description>] [--location <location>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--calendar-id <calendar-id>", "Calendar ID (default: \"primary\") (example: example-id)")
	.requiredOption("--event-id <event-id>", "Event ID (example: example-id)")
	.option("--summary <summary>", "Event title")
	.option("--description <description>", "Event description")
	.option("--location <location>", "Event location")
	.option("--start <start:iso-8601>", "Start time (ISO 8601 format)")
	.option("--end <end:iso-8601>", "End time (ISO 8601 format)")
	.option("--attendees <attendees:value1,value2>", "Attendee email addresses (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	
	.alias("update_event")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.calendarId !== undefined) args.calendarId = cmdOpts.calendarId;
		if (cmdOpts.eventId !== undefined) args.eventId = cmdOpts.eventId;
		if (cmdOpts.summary !== undefined) args.summary = cmdOpts.summary;
		if (cmdOpts.description !== undefined) args.description = cmdOpts.description;
		if (cmdOpts.location !== undefined) args.location = cmdOpts.location;
		if (cmdOpts.start !== undefined) args.start = cmdOpts.start;
		if (cmdOpts.end !== undefined) args.end = cmdOpts.end;
		if (cmdOpts.attendees !== undefined) args.attendees = cmdOpts.attendees;
			const call = (proxy.updateEvent as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.update_event(calendarId: \"example-id\", eventId:, ...)")
	.addHelpText('afterAll', () => '\n' + "// optional (3): start, end, attendees" + '\n');

program
	.command("delete-event")
	.summary("delete-event [--calendar-id <calendar-id>] --event-id <event-id> [--raw <json>]")
	.description("Delete a calendar event")
	.usage("[--calendar-id <calendar-id>] --event-id <event-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--calendar-id <calendar-id>", "Calendar ID (default: \"primary\") (example: example-id)")
	.requiredOption("--event-id <event-id>", "Event ID (example: example-id)")
	
	.alias("delete_event")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.calendarId !== undefined) args.calendarId = cmdOpts.calendarId;
		if (cmdOpts.eventId !== undefined) args.eventId = cmdOpts.eventId;
			const call = (proxy.deleteEvent as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.delete_event(calendarId: \"example-id\", eventId:, ...)");

program
	.command("find-free-time")
	.summary("find-free-time --time-min <time-min:iso-8601> --time-max <time-max:iso-8601> [--calendars <calendars:value1,value2>] [--raw <json>]")
	.description("Find free time slots across calendars")
	.usage("--time-min <time-min:iso-8601> --time-max <time-max:iso-8601> [--calendars <calendars:value1,value2>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--time-min <time-min:iso-8601>", "Start time (ISO 8601 format)")
	.requiredOption("--time-max <time-max:iso-8601>", "End time (ISO 8601 format)")
	.option("--calendars <calendars:value1,value2>", "Calendar IDs to check (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	
	.alias("find_free_time")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.timeMin !== undefined) args.timeMin = cmdOpts.timeMin;
		if (cmdOpts.timeMax !== undefined) args.timeMax = cmdOpts.timeMax;
		if (cmdOpts.calendars !== undefined) args.calendars = cmdOpts.calendars;
			const call = (proxy.findFreeTime as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.find_free_time(timeMin: \"value\", timeMax: \"value, ...)");

program
	.command("quick-add-event")
	.summary("quick-add-event [--calendar-id <calendar-id>] --text <text> [--raw <json>]")
	.description("Create event using natural language (e.g., \"Lunch tomorrow at noon\")")
	.usage("[--calendar-id <calendar-id>] --text <text> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--calendar-id <calendar-id>", "Calendar ID (default: \"primary\") (example: example-id)")
	.requiredOption("--text <text>", "Natural language event description")
	
	.alias("quick_add_event")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.calendarId !== undefined) args.calendarId = cmdOpts.calendarId;
		if (cmdOpts.text !== undefined) args.text = cmdOpts.text;
			const call = (proxy.quickAddEvent as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.quick_add_event(calendarId: \"example-id\", text:, ...)");

program
	.command("list-files")
	.summary("list-files [--query <query>] [--max-results <max-results:number>] [--order-by <order-by>] [--raw <json>]")
	.description("List files in Google Drive")
	.usage("[--query <query>] [--max-results <max-results:number>] [--order-by <order-by>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--query <query>", "Drive query string")
	.option("--max-results <max-results:number>", "Maximum number of results (default: 10) (example: 1)", (value) => parseFloat(value))
	.option("--order-by <order-by>", "Order by (e.g., \"modifiedTime desc\")")
	
	.alias("list_files")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
		if (cmdOpts.maxResults !== undefined) args.maxResults = cmdOpts.maxResults;
		if (cmdOpts.orderBy !== undefined) args.orderBy = cmdOpts.orderBy;
			const call = (proxy.listFiles as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.list_files(maxResults: 1)");

program
	.command("get-file")
	.summary("get-file --file-id <file-id> [--raw <json>]")
	.description("Get metadata for a specific file")
	.usage("--file-id <file-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--file-id <file-id>", "File ID (example: example-id)")
	
	.alias("get_file")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.fileId !== undefined) args.fileId = cmdOpts.fileId;
			const call = (proxy.getFile as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.get_file(fileId: \"example-id\")");

program
	.command("search-files")
	.summary("search-files --query <query> [--max-results <max-results:number>] [--raw <json>]")
	.description("Search files by name or content")
	.usage("--query <query> [--max-results <max-results:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--query <query>", "Search query")
	.option("--max-results <max-results:number>", "Maximum number of results (default: 20) (example: 1)", (value) => parseFloat(value))
	
	.alias("search_files")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
		if (cmdOpts.maxResults !== undefined) args.maxResults = cmdOpts.maxResults;
			const call = (proxy.searchFiles as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.search_files(query: \"value\", maxResults: 1)");

program
	.command("create-folder")
	.summary("create-folder --name <name> [--parent-id <parent-id>] [--raw <json>]")
	.description("Create a new folder in Drive")
	.usage("--name <name> [--parent-id <parent-id>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--name <name>", "Folder name")
	.option("--parent-id <parent-id>", "Parent folder ID (optional) (example: example-id)")
	
	.alias("create_folder")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.name !== undefined) args.name = cmdOpts.name;
		if (cmdOpts.parentId !== undefined) args.parentId = cmdOpts.parentId;
			const call = (proxy.createFolder as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.create_folder(name: \"value\", parentId: \"example-id\")");

program
	.command("delete-file")
	.summary("delete-file --file-id <file-id> [--raw <json>]")
	.description("Delete a file from Drive")
	.usage("--file-id <file-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--file-id <file-id>", "File ID (example: example-id)")
	
	.alias("delete_file")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.fileId !== undefined) args.fileId = cmdOpts.fileId;
			const call = (proxy.deleteFile as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.delete_file(fileId: \"example-id\")");

program
	.command("copy-file")
	.summary("copy-file --file-id <file-id> [--name <name>] [--parent-id <parent-id>] [--raw <json>]")
	.description("Create a copy of a file")
	.usage("--file-id <file-id> [--name <name>] [--parent-id <parent-id>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--file-id <file-id>", "File ID to copy (example: example-id)")
	.option("--name <name>", "New file name (optional)")
	.option("--parent-id <parent-id>", "Parent folder ID (optional) (example: example-id)")
	
	.alias("copy_file")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.fileId !== undefined) args.fileId = cmdOpts.fileId;
		if (cmdOpts.name !== undefined) args.name = cmdOpts.name;
		if (cmdOpts.parentId !== undefined) args.parentId = cmdOpts.parentId;
			const call = (proxy.copyFile as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.copy_file(fileId: \"example-id\", parentId: \"examp, ...)");

program
	.command("move-file")
	.summary("move-file --file-id <file-id> --new-parent-id <new-parent-id> [--raw <json>]")
	.description("Move a file to a different folder")
	.usage("--file-id <file-id> --new-parent-id <new-parent-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--file-id <file-id>", "File ID (example: example-id)")
	.requiredOption("--new-parent-id <new-parent-id>", "New parent folder ID (example: example-id)")
	
	.alias("move_file")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.fileId !== undefined) args.fileId = cmdOpts.fileId;
		if (cmdOpts.newParentId !== undefined) args.newParentId = cmdOpts.newParentId;
			const call = (proxy.moveFile as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.move_file(fileId: \"example-id\", newParentId: \"ex, ...)");

program
	.command("share-file")
	.summary("share-file --file-id <file-id> --email <email> [--role <role:reader|writer|commenter>] [--send-notification <send-notification:true|false>] [--raw <json>]")
	.description("Share a file with someone")
	.usage("--file-id <file-id> --email <email> [--role <role:reader|writer|commenter>] [--send-notification <send-notification:true|false>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--file-id <file-id>", "File ID (example: example-id)")
	.requiredOption("--email <email>", "Email address to share with")
	.option("--role <role:reader|writer|commenter>", "Permission role (choices: reader, writer, commenter; example: reader)")
	.option("--send-notification <send-notification:true|false>", "Send email notification (example: true)", (value) => value !== 'false')
	
	.alias("share_file")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.fileId !== undefined) args.fileId = cmdOpts.fileId;
		if (cmdOpts.email !== undefined) args.email = cmdOpts.email;
		if (cmdOpts.role !== undefined) args.role = cmdOpts.role;
		if (cmdOpts.sendNotification !== undefined) args.sendNotification = cmdOpts.sendNotification;
			const call = (proxy.shareFile as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.share_file(fileId: \"example-id\", email: \"value\", ...)");

program
	.command("get-file-content")
	.summary("get-file-content --file-id <file-id> [--mime-type <mime-type>] [--raw <json>]")
	.description("Get content of a text file")
	.usage("--file-id <file-id> [--mime-type <mime-type>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--file-id <file-id>", "File ID (example: example-id)")
	.option("--mime-type <mime-type>", "MIME type (optional)")
	
	.alias("get_file_content")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.fileId !== undefined) args.fileId = cmdOpts.fileId;
		if (cmdOpts.mimeType !== undefined) args.mimeType = cmdOpts.mimeType;
			const call = (proxy.getFileContent as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.get_file_content(fileId: \"example-id\")");

program
	.command("export-file")
	.summary("export-file --file-id <file-id> --mime-type <mime-type> [--raw <json>]")
	.description("Export a Google Doc/Sheet/Slides to another format")
	.usage("--file-id <file-id> --mime-type <mime-type> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--file-id <file-id>", "File ID (example: example-id)")
	.requiredOption("--mime-type <mime-type>", "Export MIME type (e.g., \"text/plain\", \"application/pdf\")")
	
	.alias("export_file")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.fileId !== undefined) args.fileId = cmdOpts.fileId;
		if (cmdOpts.mimeType !== undefined) args.mimeType = cmdOpts.mimeType;
			const call = (proxy.exportFile as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.export_file(fileId: \"example-id\", mimeType: \"value\")");

program
	.command("get-storage-quota")
	.summary("get-storage-quota [--raw <json>]")
	.description("Get Drive storage quota information")
	.usage("[--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	
	.alias("get_storage_quota")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			
			const call = (proxy.getStorageQuota as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.get_storage_quota()");

program
	.command("list-doc-structure")
	.summary("list-doc-structure --document-id <document-id> [--raw <json>]")
	.description("List high-level structure of a Google Doc")
	.usage("--document-id <document-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--document-id <document-id>", "Google Doc document ID (example: example-id)")
	
	.alias("list_doc_structure")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.documentId !== undefined) args.documentId = cmdOpts.documentId;
			const call = (proxy.listDocStructure as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.list_doc_structure(documentId: \"example-id\")");

program
	.command("read-doc-text")
	.summary("read-doc-text --document-id <document-id> [--raw <json>]")
	.description("Read plain text content from a Google Doc")
	.usage("--document-id <document-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--document-id <document-id>", "Google Doc document ID (example: example-id)")
	
	.alias("read_doc_text")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.documentId !== undefined) args.documentId = cmdOpts.documentId;
			const call = (proxy.readDocText as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.read_doc_text(documentId: \"example-id\")");

program
	.command("create-doc")
	.summary("create-doc --title <title> [--content <content>] [--raw <json>]")
	.description("Create a new Google Doc with optional initial content")
	.usage("--title <title> [--content <content>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--title <title>", "Document title")
	.option("--content <content>", "Initial document text (optional)")
	
	.alias("create_doc")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.title !== undefined) args.title = cmdOpts.title;
		if (cmdOpts.content !== undefined) args.content = cmdOpts.content;
			const call = (proxy.createDoc as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.create_doc(title: \"value\")");

program
	.command("append-doc-text")
	.summary("append-doc-text --document-id <document-id> --text <text> [--raw <json>]")
	.description("Append text to the end of a Google Doc")
	.usage("--document-id <document-id> --text <text> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--document-id <document-id>", "Google Doc document ID (example: example-id)")
	.requiredOption("--text <text>", "Text to append")
	
	.alias("append_doc_text")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.documentId !== undefined) args.documentId = cmdOpts.documentId;
		if (cmdOpts.text !== undefined) args.text = cmdOpts.text;
			const call = (proxy.appendDocText as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.append_doc_text(documentId: \"example-id\", text:, ...)");

program
	.command("get-sheet-values")
	.summary("get-sheet-values --spreadsheet-id <spreadsheet-id> --range <range> [--raw <json>]")
	.description("Read values from a spreadsheet range")
	.usage("--spreadsheet-id <spreadsheet-id> --range <range> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--spreadsheet-id <spreadsheet-id>", "Spreadsheet ID (example: example-id)")
	.requiredOption("--range <range>", "A1 range (e.g., Sheet1!A1:C10)")
	
	.alias("get_sheet_values")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.spreadsheetId !== undefined) args.spreadsheetId = cmdOpts.spreadsheetId;
		if (cmdOpts.range !== undefined) args.range = cmdOpts.range;
			const call = (proxy.getSheetValues as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.get_sheet_values(spreadsheetId: \"example-id\", ra, ...)");

program
	.command("update-sheet-values")
	.summary("update-sheet-values --spreadsheet-id <spreadsheet-id> --range <range> --values <values:value1,value2> [--value-input-option <value-input-option:RAW|USER_ENTERED>] [--raw <json>]")
	.description("Update values in a spreadsheet range")
	.usage("--spreadsheet-id <spreadsheet-id> --range <range> --values <values:value1,value2> [--value-input-option <value-input-option:RAW|USER_ENTERED>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--spreadsheet-id <spreadsheet-id>", "Spreadsheet ID (example: example-id)")
	.requiredOption("--range <range>", "A1 range (e.g., Sheet1!A1:C10)")
	.requiredOption("--values <values:value1,value2>", "2D values array (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--value-input-option <value-input-option:RAW|USER_ENTERED>", "Set valueInputOption. (choices: RAW, USER_ENTERED; example: RAW)")
	
	.alias("update_sheet_values")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.spreadsheetId !== undefined) args.spreadsheetId = cmdOpts.spreadsheetId;
		if (cmdOpts.range !== undefined) args.range = cmdOpts.range;
		if (cmdOpts.values !== undefined) args.values = cmdOpts.values;
		if (cmdOpts.valueInputOption !== undefined) args.valueInputOption = cmdOpts.valueInputOption;
			const call = (proxy.updateSheetValues as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.update_sheet_values(spreadsheetId: \"example-id\", ...)");

program
	.command("append-sheet-values")
	.summary("append-sheet-values --spreadsheet-id <spreadsheet-id> --range <range> --values <values:value1,value2> [--value-input-option <value-input-option:RAW|USER_ENTERED>] [--raw <json>]")
	.description("Append rows to a spreadsheet range")
	.usage("--spreadsheet-id <spreadsheet-id> --range <range> --values <values:value1,value2> [--value-input-option <value-input-option:RAW|USER_ENTERED>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--spreadsheet-id <spreadsheet-id>", "Spreadsheet ID (example: example-id)")
	.requiredOption("--range <range>", "A1 range (e.g., Sheet1!A:C)")
	.requiredOption("--values <values:value1,value2>", "2D values array (example: value1,value2)", (value) => value.split(',').map((v) => v.trim()))
	.option("--value-input-option <value-input-option:RAW|USER_ENTERED>", "Set valueInputOption. (choices: RAW, USER_ENTERED; example: RAW)")
	
	.alias("append_sheet_values")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.spreadsheetId !== undefined) args.spreadsheetId = cmdOpts.spreadsheetId;
		if (cmdOpts.range !== undefined) args.range = cmdOpts.range;
		if (cmdOpts.values !== undefined) args.values = cmdOpts.values;
		if (cmdOpts.valueInputOption !== undefined) args.valueInputOption = cmdOpts.valueInputOption;
			const call = (proxy.appendSheetValues as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.append_sheet_values(spreadsheetId: \"example-id\", ...)");

program
	.command("create-spreadsheet")
	.summary("create-spreadsheet --title <title> [--sheet-title <sheet-title>] [--raw <json>]")
	.description("Create a new Google Spreadsheet")
	.usage("--title <title> [--sheet-title <sheet-title>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--title <title>", "Spreadsheet title")
	.option("--sheet-title <sheet-title>", "Initial sheet tab name")
	
	.alias("create_spreadsheet")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.title !== undefined) args.title = cmdOpts.title;
		if (cmdOpts.sheetTitle !== undefined) args.sheetTitle = cmdOpts.sheetTitle;
			const call = (proxy.createSpreadsheet as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.create_spreadsheet(title: \"value\")");

program
	.command("get-presentation")
	.summary("get-presentation --presentation-id <presentation-id> [--raw <json>]")
	.description("Get metadata and slides for a Google Slides presentation")
	.usage("--presentation-id <presentation-id> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--presentation-id <presentation-id>", "Presentation ID (example: example-id)")
	
	.alias("get_presentation")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.presentationId !== undefined) args.presentationId = cmdOpts.presentationId;
			const call = (proxy.getPresentation as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.get_presentation(presentationId: \"example-id\")");

program
	.command("create-presentation")
	.summary("create-presentation --title <title> [--raw <json>]")
	.description("Create a new Google Slides presentation")
	.usage("--title <title> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--title <title>", "Presentation title")
	
	.alias("create_presentation")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.title !== undefined) args.title = cmdOpts.title;
			const call = (proxy.createPresentation as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.create_presentation(title: \"value\")");

program
	.command("create-slide")
	.summary("create-slide --presentation-id <presentation-id> [--layout <layout>] [--raw <json>]")
	.description("Create a slide in an existing presentation")
	.usage("--presentation-id <presentation-id> [--layout <layout>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--presentation-id <presentation-id>", "Presentation ID (example: example-id)")
	.option("--layout <layout>", "Layout enum, e.g. TITLE_AND_BODY")
	
	.alias("create_slide")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.presentationId !== undefined) args.presentationId = cmdOpts.presentationId;
		if (cmdOpts.layout !== undefined) args.layout = cmdOpts.layout;
			const call = (proxy.createSlide as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.create_slide(presentationId: \"example-id\")");

program
	.command("list-contacts")
	.summary("list-contacts [--page-size <page-size:number>] [--page-token <page-token>] [--raw <json>]")
	.description("List contacts from Google People")
	.usage("[--page-size <page-size:number>] [--page-token <page-token>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.option("--page-size <page-size:number>", "Page size (default 50) (example: 1)", (value) => parseFloat(value))
	.option("--page-token <page-token>", "Pagination token")
	
	.alias("list_contacts")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.pageSize !== undefined) args.pageSize = cmdOpts.pageSize;
		if (cmdOpts.pageToken !== undefined) args.pageToken = cmdOpts.pageToken;
			const call = (proxy.listContacts as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.list_contacts(pageSize: 1)");

program
	.command("search-contacts")
	.summary("search-contacts --query <query> [--page-size <page-size:number>] [--raw <json>]")
	.description("Search contacts by name/email/phone")
	.usage("--query <query> [--page-size <page-size:number>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--query <query>", "Search query")
	.option("--page-size <page-size:number>", "Page size (default 20) (example: 1)", (value) => parseFloat(value))
	
	.alias("search_contacts")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.query !== undefined) args.query = cmdOpts.query;
		if (cmdOpts.pageSize !== undefined) args.pageSize = cmdOpts.pageSize;
			const call = (proxy.searchContacts as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.search_contacts(query: \"value\", pageSize: 1)");

program
	.command("create-contact")
	.summary("create-contact --given-name <given-name> [--family-name <family-name>] [--email <email>] [--phone <phone>] [--company <company>] [--raw <json>]")
	.description("Create a contact in Google People")
	.usage("--given-name <given-name> [--family-name <family-name>] [--email <email>] [--phone <phone>] [--company <company>] [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--given-name <given-name>", "First name")
	.option("--family-name <family-name>", "Last name")
	.option("--email <email>", "Email address")
	.option("--phone <phone>", "Phone number")
	.option("--company <company>", "Company name")
	
	.alias("create_contact")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.givenName !== undefined) args.givenName = cmdOpts.givenName;
		if (cmdOpts.familyName !== undefined) args.familyName = cmdOpts.familyName;
		if (cmdOpts.email !== undefined) args.email = cmdOpts.email;
		if (cmdOpts.phone !== undefined) args.phone = cmdOpts.phone;
		if (cmdOpts.company !== undefined) args.company = cmdOpts.company;
			const call = (proxy.createContact as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.create_contact(givenName: \"value\")");

program
	.command("get-contact")
	.summary("get-contact --resource-name <resource-name> [--raw <json>]")
	.description("Get a contact by People resource name")
	.usage("--resource-name <resource-name> [--raw <json>]")
	.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')

	.requiredOption("--resource-name <resource-name>", "Resource name like people/c123456789")
	
	.alias("get_contact")	.action(async (cmdOpts) => {
		const globalOptions = program.opts();
		const runtime = await ensureRuntime();
		const serverName = embeddedName;
		const proxy = createServerProxy(runtime, serverName, {
			initialSchemas: embeddedSchemas,
		});
		try {
			const args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
			if (cmdOpts.resourceName !== undefined) args.resourceName = cmdOpts.resourceName;
			const call = (proxy.getContact as any)(args);
			const result = await invokeWithTimeout(call, globalOptions.timeout || 30000);
			printResult(result, globalOptions.output ?? 'text');
		} finally {
			await runtime.close(serverName).catch(() => {});
		}
	})
	.addHelpText('after', () => '\nExample:\n  ' + "mcporter call alan-google.get_contact(resourceName: \"value\")");

program
	.command('__mcporter_inspect', { hidden: true })
	.description('Internal metadata printer for mcporter inspect-cli.')
	.action(() => {
		const payload = buildMetadataPayload();
		console.log(JSON.stringify(payload, null, 2));
	});

configureToolCommandHelps();

const FORCE_COLOR = process.env.FORCE_COLOR?.toLowerCase();
const forceDisableColor = FORCE_COLOR === '0' || FORCE_COLOR === 'false';
const forceEnableColor = FORCE_COLOR === '1' || FORCE_COLOR === 'true' || FORCE_COLOR === '2' || FORCE_COLOR === '3';
const hasNoColor = process.env.NO_COLOR !== undefined;
const stdoutStream = process.stdout as NodeJS.WriteStream | undefined;
const supportsAnsiColor = !hasNoColor && (forceEnableColor || (!forceDisableColor && Boolean(stdoutStream?.isTTY)));

const tint = {
	bold(text: string): string {
		return supportsAnsiColor ? '[1m' + text + '[0m' : text;
	},
	dim(text: string): string {
		return supportsAnsiColor ? '[90m' + text + '[0m' : text;
	},
	extraDim(text: string): string {
		return supportsAnsiColor ? '[38;5;244m' + text + '[0m' : text;
	},
};

function configureGeneratedCommandHelp(command: Command): void {
	command.configureHelp({
		commandUsage(target) {
			const usage = (target.name() + ' ' + target.usage()).trim() || target.name();
			return supportsAnsiColor ? tint.bold(usage) : usage;
		},
		optionTerm(option) {
			const term = option.flags ?? '';
			return supportsAnsiColor ? tint.bold(term) : term;
		},
		optionDescription(option) {
			const description = option.description ?? '';
			return supportsAnsiColor ? tint.extraDim(description) : description;
		},
	});
}

function configureToolCommandHelps(): void {
	program.commands.forEach((cmd) => {
		if (cmd.name() === '__mcporter_inspect') {
			return;
		}
		configureGeneratedCommandHelp(cmd);
	});
}

function renderStandaloneHelp(): string {
	const colorfulTitle = tint.bold(embeddedName) + ' ' + tint.dim('â€” ' + embeddedDescription);
	const plainTitle = embeddedName + ' â€” ' + embeddedDescription;
	const title = supportsAnsiColor ? colorfulTitle : plainTitle;
	const lines = [title, '', 'Usage: ' + embeddedName + ' <command> [options]', ''];
	if (generatorTools) {
		lines.push(formatEmbeddedTools());
	}
	lines.push('', formatGlobalFlags(), '', formatQuickStart());
	if (generatorInfo) {
		lines.push('', tint.extraDim(generatorInfo));
	}
	return lines.join('\n');
}

program.helpInformation = () => renderStandaloneHelp();

function formatEmbeddedTools(): string {
	const header = supportsAnsiColor ? tint.bold('Embedded tools') : 'Embedded tools';
	if (!generatorTools.length) {
		return header;
	}
	const lines = [header];
	generatorTools.forEach((entry) => {
		const renderedDesc = entry.description
			? supportsAnsiColor
				? tint.extraDim(entry.description)
				: entry.description
			: undefined;
		const base = renderedDesc ? entry.name + ' - ' + renderedDesc : entry.name;
		lines.push('  ' + base);
		if (entry.flags) {
			const renderedFlags = supportsAnsiColor ? tint.extraDim(entry.flags) : entry.flags;
			lines.push('    ' + renderedFlags);
		}
		lines.push('');
	});
	if (lines[lines.length - 1] === '') {
		lines.pop();
	}
	return lines.join('\n');
}

function formatGlobalFlags(): string {
	const header = supportsAnsiColor ? tint.bold('Global flags') : 'Global flags';
	const entries = [
		['-t, --timeout <ms>', 'Call timeout in milliseconds'],
		['-o, --output <format>', 'text | markdown | json | raw (default text)'],
	];
	const formatted = entries.map(([flag, summary]) => '  ' + flag.padEnd(28) + summary);
	return [header, ...formatted].join('\n');
}

function formatQuickStart(): string {
  const header = supportsAnsiColor ? tint.bold('Quick start') : 'Quick start';
  const examples = quickStartExamples();
  if (!examples.length) {
    return header;
  }
  const formatted = examples.map(([cmd, note]) => '  ' + cmd + '\n    ' + tint.dim('# ' + note));
  return [header, ...formatted].join('\n');
}

function quickStartExamples(): Array<[string, string]> {
  const examples: Array<[string, string]> = [];
  const commandMap = new Map<string, string>();
  program.commands.forEach((cmd) => {
    const name = cmd.name();
    if (name !== '__mcporter_inspect') {
      commandMap.set(name, name);
    }
  });
  const embedded = Array.isArray(generatorTools) ? generatorTools : [];
  for (const entry of embedded.slice(0, 3)) {
    const commandName = commandMap.get(entry.name) ?? entry.name;
    const flags = entry.flags ? ' ' + entry.flags.replace(/<[^>]+>/g, '<value>') : '';
    examples.push([embeddedName + ' ' + commandName + flags, 'invoke ' + commandName]);
  }
  if (!examples.length) {
    examples.push([embeddedName + ' <tool> --key value', 'invoke a tool with flags']);
  }
  return examples;
}

function printResult(result: unknown, format: string) {
	const wrapped = createCallResult(result);
	switch (format) {
		case 'json': {
			const json = wrapped.json();
			if (json) {
				console.log(JSON.stringify(json, null, 2));
				return;
			}
			break;
		}
		case 'markdown': {
			const markdown = wrapped.markdown();
			if (markdown) {
				console.log(markdown);
				return;
			}
			break;
		}
		case 'raw': {
			console.log(JSON.stringify(wrapped.raw, null, 2));
			return;
		}
	}
	const text = wrapped.text();
	if (text) {
		console.log(text);
	} else {
		console.log(JSON.stringify(wrapped.raw, null, 2));
	}
}

function normalizeEmbeddedServer(server: typeof embeddedServer) {
	const base = { ...server } as Record<string, unknown>;
	if ((server.command as any).kind === 'http') {
		const urlRaw = (server.command as any).url;
		const urlValue = typeof urlRaw === 'string' ? urlRaw : String(urlRaw);
		return {
			...base,
			command: {
				...(server.command as Record<string, unknown>),
				url: new URL(urlValue),
			},
		};
	}
	if ((server.command as any).kind === 'stdio') {
		return {
			...base,
			command: {
				...(server.command as Record<string, unknown>),
				args: [ ...((server.command as any).args ?? []) ],
			},
		};
	}
	return base;
}

function determineArtifactKind(): 'template' | 'bundle' | 'binary' {
	const scriptPath = typeof process !== 'undefined' && Array.isArray(process.argv) ? process.argv[1] ?? '' : '';
	if (scriptPath.endsWith('.ts')) {
		return 'template';
	}
	if (scriptPath.endsWith('.js')) {
		return 'bundle';
	}
	return 'binary';
}

function resolveArtifactPath(): string {
	if (typeof process !== 'undefined' && Array.isArray(process.argv) && process.argv.length > 1) {
		const script = process.argv[1];
		if (script) {
			return script;
		}
	}
	return embeddedMetadata.artifact.path;
}

function buildMetadataPayload() {
	const invocation = { ...embeddedMetadata.invocation };
	const path = resolveArtifactPath();
	if (artifactKind === 'template' && path) {
		invocation.outputPath = invocation.outputPath ?? path;
	} else if (artifactKind === 'bundle' && path) {
		invocation.bundle = invocation.bundle ?? path;
	} else if (artifactKind === 'binary' && path) {
		invocation.compile = invocation.compile ?? path;
	}
	return {
		...embeddedMetadata,
		artifact: {
			path,
			kind: artifactKind,
		},
		invocation,
	};
}

async function ensureRuntime(): Promise<Awaited<ReturnType<typeof createRuntime>>> {
	return await createRuntime({
		servers: [normalizeEmbeddedServer(embeddedServer)],
	});
}

async function invokeWithTimeout<T>(call: Promise<T>, timeout: number): Promise<T> {
	if (!Number.isFinite(timeout) || timeout <= 0) {
		return await call;
	}
	let timer: ReturnType<typeof setTimeout> | undefined;
	try {
		return await Promise.race([
			call,
			new Promise<never>((_, reject) => {
				timer = setTimeout(() => {
					reject(new Error('Call timed out after ' + timeout + 'ms.'));
				}, timeout);
			}),
		]);
	} finally {
		if (timer) {
			clearTimeout(timer);
		}
	}
}

async function runCli(): Promise<void> {
	const args = process.argv.slice(2);
	if (args.length === 0) {
		program.outputHelp();
		return;
	}
	await program.parseAsync(process.argv);
}

if (process.env.MCPORTER_DISABLE_AUTORUN !== '1') {
	runCli().catch((error) => {
		const message = error instanceof Error ? error.message : String(error);
		console.error(message);
		process.exit(1);
	});
}
